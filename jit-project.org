* stash the bytecode vector on the stash during execution
  -> keeps it alive

* the cases
** TODO redefine function to nil -> all calls error

* memory cost of alloc approach to prepass
    (cl-loop for sym being the symbols
	     maximize (if (and (fboundp sym)
			       (byte-code-function-p (symbol-function sym))
			       (stringp (aref (symbol-function sym) 1)))
			  (* (length (aref (symbol-function sym) 1))
			     (aref (symbol-function sym) 3))
			0))
  => 159309
  which seems maybe steep
  should redo this perhaps to find the median
* DONE Bconstant2 -vs- switch
* TODO Bswitch could be better
  for example we could more directly the case where all keys are integers
  either by a jump table if they are compact, or by a binary search
* DONE switch needs prepass work
  and we can maybe do less work in the compiler
  for example the Bconstant handling
* DONE on branch the pc=-1 stuff in compiler has to go away
  [ we want it for other reasons now ]
* DONE on branch we can make sequences like
  (if (eq ...)) or (if (not ...)) better
  by eliminating the intermediate Qt/Qnil work
  [ done on main branch ]
* TODO do some dynamic type checking for some functions
  e.g., could inline Flength if we knew it was always called
  for the same type object
  could do this in the interpreter as well
  for this to work we need a recompilation framework
  [ see the paper Stefan sent ]
* DONE this is wrong:
  eassert (pc_list == NULL);
  have to free it instead
* DONE libjit needs a .pc file so Nick Lloyd's configure patch will work
* DONE configury must check for open_memstream
  or we need a string-based API for disassembly etc
* TODO have to insert maybe_quit calls somewhere, probably backward branches
  see also QUITP
* TODO calls to make-byte-code should probably be treated specially
  we'll need to reconstruct flow info to capture these
  the idea then is to compile the resulting bytecode just once,
  when compiling our method
  and arrange for the jitted code to pass the function pointer along
* TODO make sure that compiling closures isn't pathological
  it is - because closures construct the constant vector at runtime
  and then call make-byte-code
  think of a way to fix this up?
* TODO make direct calls to certain functions
  el-compilador has a list of functions that should be "ok"
  "ok" means the user can't advise them, and they are written in C
  we could have the compiler not indirect via Ffuncall in these cases
  or even inline some
  this may require a pre-pass to check that the function is some
  constant
  but consider:
        (defun funny-call (x) (funcall (if x 'fun-a 'fun-b) x))
  it becomes:
    0	dup
    1	goto-if-nil 1
    4	constant  fun-a
    5	goto	  2
    8:1	constant  fun-b
    9:2	stack-ref 1
    10	call	  1
    11	return
* DONE a call to another bytecode vector could use a different ABI
  but only if we had a second entry point in case the lambda
  was also called some other way
* DONE does the byte-compiler optimize mapc et al to a loop?
  seems like it should if a lambda is given
  but do we care, since people who care about performance
  should use cl-loop or something
* TODO should inline some calls at hot spots
  use a heuristic on the callee's size
  and a heuristic on the number of calls at the call site
  have to recompile if the callee changes
  probably have to emit a full call as well, with a flag
  to indicate if the callee has changed, to avoid needing
  on stack replacement
* DONE prologue could be more efficient with optional arguments
  even if we don't adopt some other ABI
  there could be a sequence of just assignments of Qnil to each arg
  and branches into the sequence
* DONE we can get rid of native_unwind_protect and just
  have the handler check FUNCTIONP
* TODO hoist a bunch of constants to some sort of prologue and make
  them universally available without recreating
  should jit-compile lambdas in the constant pool as well
  [ does this actually result in better code? ]
* DONE remove the "##" comment from bytecomp.el
* DONE change how unwind-protect is handled in bytecode
* TODO things like emit_qnil_or_qt (and similar)
  should maybe just optimistically emit qnil, since that is just 0,
  then load qt, reducing the number of branches
  maybe this would let libjit emit a cmov (can it ever?  it's hard to tell)
* DONE get_type does some shifting
  but since we compare against constants we could just pre-shift those
  [ this isn't a savings because we'd have to "and" anyway ]
* TODO could we possibly have branch hinting in the jit
  or do we need it, maybe we can just control the condition
* DONE we could emit a single call to wrong_type_argument per function
* DONE can we really set a slot in a pure bytecode object
* DONE free local data
* DONE if compilation fails mark it so we don't try again
* DONE we need unwinder support in gdb
  actually really just the function bounds
  maybe implement one of the gdb jit protocols here
  [ sent a draft of one to the libjit list ]
* DONE see if we can just use the varargs support [no]
* TODO we still don't free functions on GC
  how to free a single function from a context?
  or should we make a new context for each one?
  [ there is a libjit patch pending for this ]
* DONE jit_dump requires a different #include, but this isn't documented
* TODO maybe we want a different calling convention for some jit functions
  like fixed args, small # args no rest args
  could do error handling in core where it already exists
* TODO alloc a function for each symbol and mark as re-compilable?
  can we change the function type at these times?
* DONE consider a subr calling convention instead
  it would make each jit function shorter
  and core needs it anyhow
  could allocate a new kind of subr
  that holds on to the bytecode vector for GC
  make sure subrs are marked
  this would avoid writing to pure bytecode
* DONE it would be nice to be able to indirect calls to natives as well
  what would it take from libjit
  [ with the new plan we don't need this ]
* DONE simple branch-around-branch optimization is missing
  could not reproduce this, see branch.c
* DONE jit branches to the retq but why?
* DONE jit has no way to perform a shift by a constant?
* DONE jit has no way to sign extend as an instruction?
  or is it type conversion
* DONE is JIT_CALL_NOTHROW really correct?
  can we tie into the exception handling system somehow
  maybe but is there a benefit
